using Microsoft.EntityFrameworkCore;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using TermSAT.Formulas;
using TermSAT.RuleDatabase;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace TermSAT.NandReduction;

public class Scripts
{
    static readonly int VARIABLE_COUNT = 3;
    static readonly string DATABASE_PATH = $"nand-rules-{VARIABLE_COUNT}.db";

    // do this to create memory-based db
    //readonly string DATABASE_PATH = ":memory:"; 

    // Note: I rewrote the rule sieve algorithm from scratch in 2024.
    // The new algorithm is magnitudes of order more efficient.
    //
    //[TestMethod]
    //public void RunNandRuleGenerator()
    //{
    //    var database = new FormulaDatabase(DATABASE_PATH);
    //    database.Clear();
    //    new RuleGenerator(database, new NandFormulaGenerator(database, VARIABLE_COUNT)).Run();
    //}


    /**
     * This method generates a database of reduction rules.
     * Its basically a homegrown implementation of the [Knuth-Bendix completion method](https://en.wikipedia.org/wiki/Knuth%E2%80%93Bendix_completion_algorithm#:~:text=The%20Knuth%E2%80%93Bendix%20completion%20algorithm,problem%20for%20the%20specified%20algebra.).
     * 
     * First, all rules for all formulas with a single variable are generated.
     * Then, all rules for all formulas with exactly two variables are generated.
     * Then, all rules for exactly three variables, and so on.
     * Within each round, formulas are generated in formula order.
     * The method proceeds this way because it's a simple matter to show that  
     * if a round fails to produce any new rules 
     * then there are no more rules to produce.
     * 
     * Notes...   
     * I already know that the rules generated by this method are locally confluent.  
     * This method uses the Knuth-Bendix method because, if the method stops generating new reduction rules 
     * then we know that the current set of rules is also globally confluent.
     * As I write this, I have not run this method to termination yet, 
     * but I expect it to stop producing new rules after 6 variables.
     * But actually running this method over that many variables is actually proving to be challenging 
     * because the number of formulas to be analyzed is enormous.
     */

    [TestMethod]
    public static void RunNandRuleGenerator(FormulaDatabase formulaDatabase)
    {
        formulaDatabase.Clear();

        using (var ctx = formulaDatabase.GetDatabaseContext())
        {
            InstanceRecognizer instanceRecognizer = new InstanceRecognizer();
            // prime the prefix tree used to recognize substitution instances of reducible formulas.
            {
                var allNonCanonical = ctx.FormulaRecords.Where(_ => _.IsCanonical == false);
                foreach (var nonCanonical in allNonCanonical)
                {
                    instanceRecognizer.Add(Formula.Parse(nonCanonical.Text));
                }
            }

            int nextFormulaId = ctx.FormulaRecords.Any() ? ctx.FormulaRecords.OrderByDescending(_ => _.Id).First().Id + 1 : 1;

            // In order to be able to use induction to show that there are no rules with more than 6 variables, 
            // rules with exactly N variables are generated, from N = 1 to 7.
            for (int variableNumber = 1; variableNumber <= 7; variableNumber++)
            {
                int saveStartId = nextFormulaId;

                Trace.WriteLine($"Start generating all rules with exactly {variableNumber} variables.");

                // start by adding variable formula to database
                Trace.WriteLine($"Start by adding a new variable, {variableNumber}.");
                var variableFormula = Variable.NewVariable(variableNumber);
                {
                    var varRecord = ctx.FormulaRecords.Where(_ => _.Text == variableFormula.ToString()).FirstOrDefault();
                    if (varRecord != null)
                    {
                        Trace.WriteLine($"Skipping, variable already exists: {variableFormula}");
                        nextFormulaId = varRecord.Id++;
                    }
                    else
                    {
                        var variableForumulaId = nextFormulaId++;
                        ctx.FormulaRecords.Add(new FormulaRecord(variableForumulaId, variableFormula, isCanonical: true));
                        ctx.SaveChanges();
                        ctx.Clear();
                        Trace.WriteLine($"New variable added: {variableFormula}");
                    }
                }

                Trace.WriteLine($"Now, generate all possible formulas with exactly {variableNumber} variables...");

                /* 
                 * 'Complete' the set of formulas by completing each formula added to the db, starting with the new variable.  
                 * Complete each formula by combining it all completed canonical formulas, ie create the deductive closure of the formula.  
                 * In order to create the minimal closure, formulas need to be completed in formula order.
                 */
                while (ctx.FormulaRecords.Where(_ => !_.IsCompleted).Any()) // repeat while there are uncompleted formulas
                {

                    // select the 'smallest' formula, ie the first formula from the formulas in formula order.
                    var todoRecord = ctx.FormulaRecords.Where(f => !f.IsCompleted).OrderBy(_ => _.Length).ThenBy(_ => _.Text).First();
                    var todoFormula = Formula.Parse(todoRecord.Text);
                    var todoId = todoRecord.Id;
                    todoRecord.IsCompleted = true;
                    ctx.SaveChanges();

                    var todoCount = ctx.FormulaRecords.Where(_ => !_.IsCompleted).Count();

                    // we only need to complete canonical formulas
                    if (!todoRecord.IsCanonical)
                    {
                        // if this formula is reducible using the rules generated so far then it can just be removed from the db
                        if (FormulaCanBeReduced(ctx, instanceRecognizer, todoFormula))
                        {
                            Debug.Assert(!todoRecord.IsCanonical);
                            ctx.FormulaRecords.Remove(todoRecord);

                            Trace.Write($"Removed from db, formula can be reduced [{todoId}]: {todoRecord.Text}.  ");
                            Trace.WriteLine($"{todoCount} formulas remaining.");
                        }
                        else
                        {
                            // going forward, we'll prevent substitution instances of this formula from becoming new rules.
                            instanceRecognizer.Add(todoFormula);

                            Trace.Write($"Formula is new reduction rule [{todoId}]: {todoRecord.Text}.  ");
                            Trace.WriteLine($"{todoCount} formulas remaining.");

                            //// Used to check for existing rules that are subsumed by the new rule and can be removed.
                            //// This is super expensive, super slow, and can be done afterwards, so removed.
                        }

                        ctx.SaveChanges();
                        ctx.Clear();
                        continue;
                    }

                    Trace.Write($"Complete formula [{todoId}]: {todoRecord.Text}.  ");
                    Trace.WriteLine($"{todoCount} formulas remaining.");

                    var previousCanonicalRecords = ctx.FormulaRecords.AsNoTracking()
                        .Where(_ => _.IsCanonical == true && _.IsCompleted)
                        .OrderBy(_ => _.Length)
                        .ThenBy(_ => _.Text);

                    List<Formula> derivedFormulas = new();
                    foreach (var previousCanonicalRecord in previousCanonicalRecords)
                    {
                        var previousCanonical = Formula.Parse(previousCanonicalRecord.Text);
                        foreach (var derivedFormula in new[] { 
                            Nand.NewNand(previousCanonical, todoFormula), 
                            Nand.NewNand(todoFormula, previousCanonical) })
                        {
                            // No need to complete formulas with less than {variableNumber} variables, 
                            // completing them won't generate any new rules that werent generated when completing previous variables.  
                            if (derivedFormula.AllVariables.Count < variableNumber)
                            {
                                Trace.WriteLine($"Not added to db, less than {variableNumber} variables : {derivedFormula}");
                                continue;
                            }

                            // if already in database then skip
                            if (ctx.FormulaRecords.Where(_ => _.Text == derivedFormula.ToString()).Any())
                            {
                                Trace.WriteLine($"Not added to db, already in database : {derivedFormula}");
                                continue;
                            }

                            // No need to complete formulas that can already be reduced.
                            if (FormulaCanBeReduced(ctx, instanceRecognizer, derivedFormula))
                            {
                                Trace.WriteLine(false, $"Not added to db, can already be reduced : {derivedFormula}");
                                continue;
                            }

                            if (!derivedFormulas.Contains(derivedFormula))
                            {
                                derivedFormulas.Add(derivedFormula);
                            }
                        }
                    }
                    derivedFormulas.Sort((a,s) => a.CompareTo(s));

                    if (derivedFormulas.Any())
                    {
                        foreach (var derivedFormula in derivedFormulas)
                        {
                            var tt = TruthTable.NewTruthTable(derivedFormula);
                            Formula canonicalFormula = null;
                            var canonicalRecord = ctx.FindCanonicalRecord(tt);
                            if (canonicalRecord != null)
                            {
                                canonicalFormula = Formula.Parse(canonicalRecord.Text);
                            }

                            // Formulas are not generated in formula order, so we might generate a formula shorter than the current canonical form.
                            // That's OK though, we can just patch them up as long as both formulas have not yet been completed
                            if (canonicalFormula != null && derivedFormula.CompareTo(canonicalFormula) < 0)
                            {
                                if (canonicalRecord.IsCompleted)
                                {
                                    throw new TermSatException("Non-canonical formulas are expected to come after their canonical form in the formula order." +
                                        $"\n    canonical: {canonicalRecord.Id}:{canonicalFormula}" +
                                        $"\n    derived: {nextFormulaId}:{derivedFormula}" +
                                        $"\n    todo: {todoId}:{todoFormula}"); 
                                }
                                canonicalRecord.IsCanonical = false;
                                ctx.SaveChanges();
                                canonicalRecord = null;
                                canonicalFormula = null;
                            }

                            var nextRecord = new FormulaRecord(nextFormulaId, derivedFormula, canonicalFormula == null);
                            ctx.FormulaRecords.Add(nextRecord);
                            ctx.SaveChanges();
                            ctx.Clear();

                            if (nextRecord.IsCanonical)
                            {
                                Trace.WriteLine($"Added uncompleted canonical formula: {derivedFormula}");
                            }
                            else
                            {
                                Trace.WriteLine($"Added uncompleted non-canonical formula: {derivedFormula} => {canonicalFormula}");
                            }

                            nextFormulaId++;
                        }
                    }
                }
            }
        }
    }

    /*
     * A formula can be reduced if it is a substitution instance of 
     * a previously generated non-canonical formula.
     * Since new formulas are assembled from previously generated canonical 
     * formulas all subformulas of the given formula are guaranteed
     * to be non-reducible.   
     */
    public static bool FormulaCanBeReduced(RuleDatabaseContext ctx, InstanceRecognizer instanceRecognizer, Formula formula) 
    {
        SubstitutionInstance match = instanceRecognizer.FindFirstGeneralization(formula);
        if (match == null)
            return false;
        var canonicalRecord = ctx.FindCanonicalRecord(TruthTable.NewTruthTable(match.Generalization));

        // if 
        //  the canonical form of the generalization is the same subLength as the generalization 
        //  (in other words, if the result of applying the associated reduction rule will 
        //  result in a new formula of the same subLength as the formula being checked) 
        // then 
        //  the formula to be checked is only reducible if the reduced formula is simpler
        //
        // This check is required because the reduction rules that reduce all the shortest 
        // formulas for a truth table to a single formula are conditional, they are only 
        // applied when the result is 'simpler'.
        if (canonicalRecord.Length == match.Generalization.Length)
        {
            Formula canonicalFormula = Formula.Parse(canonicalRecord.Text);
            var reducedFormula = canonicalFormula.CreateSubstitutionInstance(match.Substitutions);
            if (0 <= reducedFormula.CompareTo(formula))
                return false;
        }

        return true;
    }



    [TestMethod]
    public void RunNandRuleReport()
    {
        var database = new FormulaDatabase(DATABASE_PATH);
        var options = new DatabaseReport.DatabaseReportOptions();
        if (VARIABLE_COUNT <= 2)
            options.ShowNonCanonicalFormulas = true;
        new DatabaseReport(database, options).Run();
    }


    /// <summary>
    /// Demonstrates that the basic reduction scheme is subsumes all reduction rules of 3 variables or less.  
    /// This is done by using the basic reduction scheme to reduce all non-canonical formulas of 3 variables 
    /// or less to their canonical formula.
    /// </summary>
    public static async Task<bool> DiscoverRulesSubsumedBySchemeAsync(FormulaDatabase formulaDatabase)
    {
        bool isEquivalent = true;
        foreach (var formula in formulaDatabase.GetAllNonCanonicalFormulas())
        {
            TruthTable truthTable = TruthTable.NewTruthTable(formula);
            var canonicalFormulas = formulaDatabase.GetCanonicalFormulas(truthTable);
            Debug.Assert(canonicalFormulas.Count == 1, "there is never more than 1 canonical formula");
            var canonicalFormula = canonicalFormulas[0];

            Debug.Assert(canonicalFormula.Length <= formula.Length, "non-canonical formulas are never shorter than canonical formulas");
            //if (canonicalFormula.Length == formula.Length)
            //{
            //    Trace.WriteLine($"Skipping {formula}, canonical form: {canonicalFormula}");
            //    continue;
            //}

            try
            {
                Formula reducedFormula = formula.Reduce();

                if (reducedFormula.Equals(canonicalFormula))
                {
                    await formulaDatabase.IsSubsumedBySchemeAsync(formula, "yes");
                    Trace.WriteLine($"nand reduction reduces {formula} to canonical form: {canonicalFormula}");
                }
                else
                {
                    isEquivalent = false;
                    await formulaDatabase.IsSubsumedBySchemeAsync(formula, "");
                    Trace.WriteLine("nand reduction does not reduce this formula to its canonical form...");
                    Trace.WriteLine("=== non-canonical form ===");
                    Trace.WriteLine(formula.ToString());
                    Trace.WriteLine("=== canonical form ===");
                    Trace.WriteLine(canonicalFormula.ToString());

                    //break;
                }

            }
            catch (Exception ex)
            {
                await formulaDatabase.IsSubsumedBySchemeAsync(formula, "error");
                Trace.WriteLine($"error: {formula}");
            }
        }

        return isEquivalent;
    }

}
