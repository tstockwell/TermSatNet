using Microsoft.EntityFrameworkCore;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Diagnostics;
using System.Linq;
using TermSAT.Formulas;

namespace TermSAT.RuleDatabase;

/// <summary>
/// 
/// A new version of FormulaRecord where, instead of just storing information about formulas, 
/// ReductionRecord also includes information about the reductions between them.
/// This is because there's no way the rule database will ever be complete, there's just too many formulas.
/// Though, I hope to complete formulas with 5 variables.
/// Unlike FormulaRecord, a ReductionRecord-based database can be incomplete but still useful.
/// And unlike FormulaRecord, RR is extensible with new formulas and reductions.
/// 
/// ----------------
/// 
/// A reduction is an atomic transform from one startingFormula to a simpler, logically equivalent startingFormula.  
/// A proof is a list of reductions that transform a starting startingFormula to an equivalent, less complex, startingFormula.
/// A reduction is a step in a proof.
/// A reduction maps all the elements in the simpler formulas' flatterm to its position in the starting startingFormula.  
/// In this way it's possible to understand exactly how a starting startingFormula was modified to get the resulting startingFormula.
/// 
/// For instance, if a new startingFormula was created by swapping the arguments to a nand operator (|.2.1 => |.1.2) then...
/// ```
///     reduction.Mapping = Enumerable.Range(0,1)
///         .Concat(Enumerable.Range(startingFormula.Antecedent.Length + 1, startingFormula.Subsequent.Length))
///         .Concat(Enumerable.Range(1, startingFormula.Antecedent.Length));
/// ```
/// ...is a mapping that maps all the terms in |.2.1, for 0 to (|.2.1).Length-1, to terms in |.1.2.
///     
/// A reduction is an asymmetric operation because there may be new subterms in the reduced startingFormula that 
/// do not exist in the starting startingFormula.
/// 
/// Lucid creates and reuses a database of reduction rules that reduce a given startingFormula to it canonical form.  
/// These proofs are called 'reduction proofs'.
/// Initially a startingFormula will have a reduction proof that has no reductions.
/// If a startingFormula can no longer be reduced then it 
/// then it has been proved to be canonical and 
/// the last reduction in a proof will have RuleDescription == CANONICAL.
/// When a reduction proofs ReducedFormula is canonical then the proof is complete and no longer updated.
/// 
/// </summary>
public partial class ReductionRecord
{
    public static string PROOF_IS_COMPLETE = "PROOF_IS_COMPLETE";

    public override string ToString()
    {
        return $"Id:{Id},Length:{Length},VarCount:{VarCount},Text:{Text}";
    }


    /*************
     * BASIC INFORMATION ABOUT THE STARTING FORMULA 
     *************/

    /// <summary>
    /// Uniquely identifies a record and also reflects the order in which formulas have been added to the system.  
    /// The only reason a formula has an Id is because I'm concerned about 
    /// storage consequences in a real-life rule system when using the Text column as a key .
    /// Must be greater than zero.
    /// </summary>
    [Key]
    public long Id { get; set; }

    /// <summary>
    /// The startingFormula as a string.
    /// This field serves as a formulas' database-independent Id.
    /// A formulas' Text can be converted into a [Godel number](https://en.wikipedia.org/wiki/G%C3%B6del_numbering) by substituting 0's for the nand operators.
    /// </summary>
    [Required]
    public string Text { get; set; }

    /// <summary>
    /// The length of the startingFormula.
    /// Not the same as the length of the startingFormula's Text column.
    /// </summary>
    [Required]
    public int Length { get; set; }

    /// <summary>
    /// Actually, the number of the highest variable in the startingFormula.
    /// This number represents the iteration in which the startingFormula were generated 
    /// if all formulas were generated by the # of variables in the startingFormula, numbered from 1 to N.
    /// </summary>
    [Required]
    public int VarCount { get; set; }


    /// <summary>
    /// Points to the next reduction in the sequence of reductions that lead to this expressions' canonical form.
    /// If this expression is canonical then this.NextReductionId == this.Id.  
    /// If the next reduction is not yet known then NextReductionId == null.
    /// This property is write-once, once set then this property should never change.
    /// <see cref="IsComplete"/>
    /// </summary>
    public long NextReductionId 
    {  
        get => _nextReductionId; 
        set
        {
#if DEBUG
            if (value == 0 || (value == Id && !IsCanonical))
            {
                throw new TermSatException($"Invalid {nameof(NextReductionId)}:{value}");
            }
#endif
            _nextReductionId = value;
        }
    }
    private long _nextReductionId= 0;

    /// <summary>
    /// Set to a description of the rule used to deduce the reduction from the starting startingFormula to the next startingFormula.
    /// Examples...
    /// "|F.1 => T"
    /// "wildcard in antecedent: {subterm}->F"
    /// 
    /// Set to Reduction.PROOF_IS_COMPLETE when StartingNand is canonical.
    /// 
    /// todo: maybe instead of using a string to identify reduction types use objects instead.  
    /// </summary>
    public string RuleDescriptor 
    { 
        get => _ruleDescriptor;
            
        set
        {
#if DEBUG
            if (!string.IsNullOrWhiteSpace(_ruleDescriptor))
            {
                throw new TermSatException($"RuleDescriptor should be write-once.\n current:{_ruleDescriptor}, new value:{value}");
            }
#endif
            _ruleDescriptor = value;
        }
    }
    private string _ruleDescriptor= null;


    /// <summary>
    /// The Id of the canonical form of this expression.  
    /// If this expression is canonical then this.Id == this.CanonicalId.  
    /// 
    /// The canonical form of an expression is not usually known when an expression is inserted into the rule db 
    /// and therefore CanonicalId is usually null when inserted.  
    /// </summary>
    public long CanonicalId { get; set; }

    /// <summary>
    /// Indicates that this startingFormula is known to be canonical.
    /// </summary>
    public bool IsCanonical
    {
        get => RuleDescriptor == ReductionRecord.PROOF_IS_COMPLETE;
        set
        {
            RuleDescriptor = ReductionRecord.PROOF_IS_COMPLETE;
            CanonicalId = NextReductionId = Id;
        }
    }


    /// <summary>
    /// Only used by the 'rule generation script'.
    /// RR has a chicken and egg problem.
    /// Wildcard analysis cant be used to generate rules until after its shown to work correctly.
    /// So initially, rules are generated using truth tables.  
    /// This column is only needed to prove that RR is correct and complete, its not required in a production database.
    /// </summary>
    public string TruthValue { get; set; }


    /// <summary>
    /// Indicates that this startingFormula has been indexed, aka added to the Lookup table.
    /// -1 = no value, 0 = false, 1 = true
    /// 
    /// This property is not used by the LE reduction process, 
    /// it's used by the <see cref="NandReduction.Scripts.RunNandRuleGenerator"/> script to 
    /// index expressions concurrently while generating rules.
    /// </summary>
    public int IsIndexed { get; set; } = -1;

    /// <summary>
    /// A marker that indicates that this rule, aka non-canonical formula, 
    /// is implemented, aka subsumed, by the reduction algorithm.
    /// Put another way, the reduction algorithm has been shown to reduce 
    /// this formula and any substitution instance of it.  
    /// </summary>
    public string IsSubsumed { get; set; } = null;

    /// <summary>
    /// A flag that indicates that 'material term discovery' has been completed for this formula.
    /// </summary>
    public bool IsDiscoveryComplete { get; internal set; }


    [NotMapped]
    public Formula Formula 
    { 
        get
        {
            if (_startingFormula == null && !string.IsNullOrWhiteSpace(Text))
            {
                _startingFormula = Formula.GetOrParse(Text);
            }
            return _startingFormula;
        }
    }
    private Formula _startingFormula {  get; set; }

    /// <summary>
    /// Creates a record populated with starting formula info.
    /// Don;t forget to set the Id before adding it to a db
    /// </summary>
    /// <param name="startingFormula"></param>
    public ReductionRecord(Formula startingFormula, bool isCanonical = false)
    {
        Text = startingFormula.ToString();
        Length = startingFormula.Length;
        VarCount = 0;
        var allVariables = startingFormula.AllVariables;
        if (allVariables.Any())
        {
            VarCount = allVariables.Select(_ => _.Number).Max();
        }
        _startingFormula = startingFormula;
        //Mapping = Enumerable.Repeat(-1, Length).ToArray();
        if (isCanonical)
        {
            RuleDescriptor = ReductionRecord.PROOF_IS_COMPLETE;
        }
    }

    public ReductionRecord(Formula startingFormula, int varCount, string truthValue)
    {
        Text = startingFormula.ToString();
        Length = startingFormula.Length;
        VarCount = varCount;
        TruthValue = truthValue;
        _startingFormula = startingFormula;
    }
    private ReductionRecord()
    {
    }

}

public partial class ReductionRecord
{
    public static void OnModelCreating(ModelBuilder modelBuilder, string tableName)
    {
        modelBuilder.Entity<ReductionRecord>(f => f.ToTable(tableName));

        modelBuilder.Entity<ReductionRecord>().Ignore(_ => _.Formula);

        modelBuilder.Entity<ReductionRecord>().Property(f => f.Id).IsRequired().ValueGeneratedOnAdd();
        modelBuilder.Entity<ReductionRecord>().Property(f => f.Text).IsRequired();
        modelBuilder.Entity<ReductionRecord>().Property(f => f.VarCount).IsRequired();
        modelBuilder.Entity<ReductionRecord>().Property(f => f.Length).IsRequired();
        //modelBuilder.Entity<ReductionRecord>().Property(f => f.Mapping);
        //modelBuilder.Entity<FormulaRecord>().Property(f => f.TruthValue).IsRequired();
        //modelBuilder.Entity<FormulaRecord>().Property(f => f.Subsumed).HasDefaultValue(-1);
        //modelBuilder.Entity<FormulaRecord>().Property(f => f.Evaluated).HasDefaultValue(-1);
        //modelBuilder.Entity<FormulaRecord>().Property(f => f.Indexed).HasDefaultValue(-1);
        //modelBuilder.Entity<FormulaRecord>().Property(f => f.Closed).HasDefaultValue(-1);
        modelBuilder.Entity<ReductionRecord>().Property(f => f.IsDiscoveryComplete).HasDefaultValue(false);
        modelBuilder.Entity<ReductionRecord>().Ignore(_ => _.IsCanonical);


        modelBuilder.Entity<ReductionRecord>().HasKey(f => f.Id);

        modelBuilder.Entity<ReductionRecord>().HasIndex(f => f.VarCount);
        modelBuilder.Entity<ReductionRecord>().HasIndex(f => f.Length);
        modelBuilder.Entity<ReductionRecord>().HasIndex(f => f.Text).IsUnique();
        modelBuilder.Entity<ReductionRecord>().HasIndex(f => f.TruthValue);
        modelBuilder.Entity<ReductionRecord>().HasIndex(f => f.NextReductionId);
        modelBuilder.Entity<ReductionRecord>().HasIndex(f => f.RuleDescriptor);
        modelBuilder.Entity<ReductionRecord>().HasIndex(f => f.CanonicalId);
        modelBuilder.Entity<ReductionRecord>().HasIndex(_ => new { _.VarCount, _.Length, _.Text }); // startingFormula order
        modelBuilder.Entity<ReductionRecord>().HasIndex(_ => new { _.TruthValue, _.VarCount, _.Length, _.Text });

        modelBuilder.Entity<ReductionRecord>().HasIndex(f => f.IsIndexed);
        modelBuilder.Entity<ReductionRecord>().HasIndex(f => f.IsSubsumed);
        //modelBuilder.Entity<ReductionRecord>().HasIndex(f => f.IsCanonical);
    }
}
