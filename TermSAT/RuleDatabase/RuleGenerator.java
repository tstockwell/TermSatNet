/*******************************************************************************
 * termsat SAT solver
 *     Copyright (C) 2010 Ted Stockwell <emorning@yahoo.com>
 * 
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Affero General Public License as
 *     published by the Free Software Foundation, either version 3 of the
 *     License, or (at your option) any later version.
 * 
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Affero General Public License for more details.
 * 
 *     You should have received a copy of the GNU Affero General Public License
 *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package com.googlecode.termsat.core.ruledb;

import java.sql.SQLException;
import java.util.Iterator;
import java.util.List;

import com.googlecode.termsat.core.Formula;
import com.googlecode.termsat.core.InstanceRecognizer;
import com.googlecode.termsat.core.SubstitutionInstance;
import com.googlecode.termsat.core.utils.ServerCommandLineInterface;


/**
 * This program generates a beginning database (RuleDatabase) of reduction rules for reducing 
 * propositional statements that are substitution instances instances of formulas 
 * with 3 or less variables.
 * 
 * For a given truth table, we call the shortest possible formulas with 
 * the given truth table 'canonical'.  Longer formulas are non-canonical.
 * This program generates reduction rules by generating every possible 
 * propositional formula of a given length and its associated truth table.
 * If a formula is non-canonical and is not reducible by a previous rule 
 * then it is a new reduction rule and is added to the database of reduction rules.
 * If more than one canonical formula is discovered for a given truth table then 
 * the first found formula is considered canonical and the others are considered 
 * reduction rules.
 * 
 * This program starts by generating all formulas with a length of 1, then 
 * it will generate all formulas with a length of 2, and so on.
 * This program stops generating reduction rules when every possible formula 
 * that is <= to twice the length of the longest canonical formula has been 
 * generated (because formulas longer than that are guaranteed to be reducible
 * by a previously generated reduction rule). 
 * 
 * The database of basic reduction rules generated by this program is then 
 * used as input into the RuleIndexer and RuleRepository programs.  
 * 
 * @see doc/summary.wiki for a more complete description of all the applications 
 * in the termSAT project.
 * 
 * @author Ted Stockwell
 */
public class RuleGenerator {
	
	public static void main(String[] args) {
		new RuleGenerator().run();
	}

	private FormulaGenerator _formulaGenerator;
	private ServerCommandLineInterface _commandLine;
	private RuleDatabase _database;
	private InstanceRecognizer _recognizer= new InstanceRecognizer();
	

	public void run() {

		try {
			setup();
			
			Formula formula = _formulaGenerator.getStartingFormula();

			while (formula != null && !_commandLine.isShutdown()) {

				processFormula(formula);
				formula = _formulaGenerator.getNextWellFormedFormula();
			}

		} 
		catch (Throwable e) {
			e.printStackTrace();
		}
		finally {
			shutdown();
		}

	}

	private void setup() throws SQLException {
		addShutdownHook();
		
		_commandLine= new ServerCommandLineInterface("Rule Generator", ">>> ");
		ServerCommandLineInterface.start(_commandLine, System.in, System.out);

		_database = new RuleDatabase();
		_formulaGenerator= new FormulaGenerator(_database);
		
		for (Iterator<Formula> i= _database.getAllNonCanonicalFormulas(); i.hasNext();) {
			_recognizer.addFormula(i.next());
		}
	}

	private void processFormula(Formula formula) {
		
		ReductionRule reductionRule= formulaCanBeReduced(formula);
		if (reductionRule== null) {
			
			boolean isCanonical= isCanonicalFormula(formula);
			
			if (isCanonical) {
					System.out.println(formula+" is canonical.");
			}
			else {
				_recognizer.addFormula(formula);
				reductionRule= new ReductionRule(formula, _database.findCanonicalFormula(formula));
				System.out.println("Found a new reduction rule: "+reductionRule);
			}
			_database.addFormula(formula, isCanonical);
		}
		else {
			System.out.println(formula+" can be reduced using rule "+reductionRule);
		}
	}

	private Boolean isCanonicalFormula(Formula formula) {
		TruthTable truthTable= TruthTables.getTruthTable(formula);
		int length= _database.getLengthOfCanonicalFormulas(truthTable);
		if (length < 0) // no canonical formulas in database
			return true;
		
		if (formula.length() <= length) {
			
//			/* 
//			 * If there are other canonical formulas with the same truth 
//			 * table and this formula is not a substitution instance of any 
//			 * of those other canonical formulas then we make this formula 
//			 * a reduction rule.
//			 * Doing this reduces the number of canonical formulas and greatly 
//			 * reduces the total number of reduction rules. 
//			 * We only do this for formulas that are not substitution instances 
//			 * of existing canonical formula in order to preserve the confluence 
//			 * of the reduction rules.
//			 */
//			List<Formula> canonicalFormulas= _database.getCanonicalFormulas(truthTable);
//			if (!canonicalFormulas.isEmpty()) {
//				if (new InstanceRecognizer(canonicalFormulas).findFirstMatch(formula) != null)  
//					return false;
//			}
			
			return true;
		}
		
		return false; 
	}

	/*
	 * A formula can be reduced if it is a substitution instance of 
	 * a previously generated non-canonical formula.
	 * Since new formulas are assembled from previously generated canonical 
	 * formulas then all subformulas of the given formula are guaranteed
	 * to be non-reducible.   
	 */
	private ReductionRule formulaCanBeReduced(Formula formula) {
		SubstitutionInstance match= _recognizer.findFirstMatch(formula);
		if (match == null)
			return null;
		Formula canonicalFormula= _database.findCanonicalFormula(match.canonicalFormula);
		return new ReductionRule(match.canonicalFormula, canonicalFormula);
	}

	private void shutdown() {
		_database.shutdown();
	}

	private void addShutdownHook() {
		Runtime.getRuntime().addShutdownHook(new Thread() {
			@Override
			public void run() {
				_commandLine.shutDown();
			}
		});
	}

}
