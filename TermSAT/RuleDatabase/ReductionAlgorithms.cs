using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using TermSAT.Formulas;

namespace TermSAT.RuleDatabase
{
    /// <summary>
    /// After the RuleGenerator program generated all reduction rules necessary to reduce 
    /// all formulas with three or less variables it became apparent that ALL of those 
    /// reduction rules could be reduced to a simple algorithm.
    /// 
    /// That algorthm is implemented here, along with any other algorithms 'discovered' 
    /// by the RuleCompletionGenerator program.
    /// 
    /// </summary>
    public static class ReductionAlgorithms
    {
        /// <summary>
        /// While developing TermSAT, the RuleGenerator program was used to generate reduction rules 
        /// for all formulas of three variables or less.  Then it was discovered that all these 
        /// reduction rules could be replaced by a simple algorithm that TermSAT calls the 
        /// 'single replacement' algorithm.
        /// 
        /// Basically the algorithm is this...  
        /// 
        /// If a formula C (could be a single variable) appears in the consequent of an implication and 
        /// if replacing all occurences of formula C in the consequent with either T or F makes the entire 
        /// consequent true (and hence, makes the original formula true) then 
        /// replace all occurences of C that appear in the original formula's antecendent with the opposite 
        /// value. For instance, if replacing C with T makes the consequent true then replace all occurences 
        /// of C in the antecedent with F.
        /// 
        /// Also, the converse is true...
        /// 
        /// If a formula C (could be a single variable) appears in the antecedent of an implication and 
        /// if replacing all occurence of formula C in the antecedent with either T or F makes the entire 
        /// antecedent false (and hence, makes the original formula true) then 
        /// replace all occurences of C that appear in the original formula's consequent with the opposite 
        /// value. For instance, if replacing C with T makes the antecedent true then replace all occurences 
        /// of C in the consequent with F.
        /// 
        /// Since the set of reduction rules generated by the RuleGenerator for 3 variables are sufficient to reduce 
        /// all substitution instances of formulas with three variables (augmented with a few rules to eliminate 
        /// constants and double negatives) the single replacement rules is also 
        /// sufficient for redcing all substitution instances of formulas with three variables.
        /// 
        /// The single replacement rule is far more powerful than all the reduction rules it replaces since 
        /// the single replacement rule is essentially the equivalent of an infinite set of similar reduction rules.
        /// That makes me wonder...  an infinite number of reductions rules would be necessary in order to reduce 
        /// boolean formulas of arbitrary length, but maybe there are is a finite set of 'algorithmic rules' 
        /// that are sufficient to solve arbitrary boolean formulas.
        /// So... my plan is to keep generating new reduction rules as a way to discover new 'algorithmic' rules.
        /// Perhaps at some point I'll be able to show that a finite set of algortmic rules is sufficient 
        /// to solve SAT problems.
        /// 
        /// </summary>
        /// <returns>A reduced formula, or the original formula if the orginal formula connot be reduced.</returns>
        public static async Task<Formula> ReduceUsingSingleReplacement(Formula formula)
        {
            if (formula is Constant)
                return formula;

            if (formula is Variable)
                return formula;

            if (formula is Negation)
            {
                var child = (formula as Negation).Child;
                var reducedChild = await ReduceUsingSingleReplacement(child);
                if (reducedChild != child)
                    return Negation.NewNegation(reducedChild);
                return formula;
            }

            Implication i = formula as Implication;
            var consequentTask = Task.Run(() => { return ReduceUsingSingleReplacement(i.Consequent); });
            var antecedentTask = Task.Run(() => { return ReduceUsingSingleReplacement(i.Antecedent); });

            var consequent = await consequentTask;
            var antecedent = await consequentTask;

            if (consequent != i.Consequent || antecedent != i.Antecedent)
                return Implication.NewImplication(antecedent, consequent);

            return formula;
        }
    }
}
