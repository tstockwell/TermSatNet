/*******************************************************************************
 * termsat SAT solver
 *     Copyright (C) 2010 Ted Stockwell <emorning@yahoo.com>
 * 
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Affero General Public License as
 *     published by the Free Software Foundation, either version 3 of the
 *     License, or (at your option) any later version.
 * 
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Affero General Public License for more details.
 * 
 *     You should have received a copy of the GNU Affero General Public License
 *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
using System;
using System.Diagnostics;
using TermSAT.Formulas;

namespace TermSAT.RuleDatabase
{


    /**
     * This program generates a beginning database of reduction rules for reducing 
     * propositional statements that are substitution instances instances of formulas 
     * with 3 or less variables.
     * 
     * For a given truth table, we call the shortest possible formulas with 
     * the given truth table 'canonical'.  Longer formulas are non-canonical.
     * This program generates reduction rules by generating every possible 
     * propositional formula of a given length and its associated truth table.
     * If a formula is non-canonical and is not reducible by a previous rule 
     * then it is a new reduction rule and is added to the database of reduction rules.
     * 
     * This program starts by generating all formulas with a length of 1, then 
     * it will generate all formulas with a length of 2, and so on.
     * This program stops generating reduction rules when every possible formula 
     * that is <= to twice the length of the longest canonical formula has been 
     * generated (because formulas longer than that are guaranteed to be reducible
     * by a previously generated reduction rule). 
     * 
     * The database of basic reduction rules generated by this program is then 
     * used as input into the RuleIndexer program.  
     * 
     * @see doc/summary.wiki for a more complete description of all the applications 
     * in the termSAT project.
     * 
     * @author Ted Stockwell
     */
    public class RuleGenerator
    {
        private FormulaGenerator _formulaGenerator;
        private FormulaDatabase _database;
        private InstanceRecognizer _recognizer = new InstanceRecognizer();

        public RuleGenerator(FormulaDatabase database, FormulaGenerator formulaGenerator)
        {
            _database = database;
            _formulaGenerator= formulaGenerator;
        }


        public void Run()
        {

            try
            {
                Setup();

                Formula formula = _formulaGenerator.GetStartingFormula();

                while (formula != null)
                {

                    ProcessFormula(formula);

                    var previousFormula= formula;
                    formula = _formulaGenerator.GetNextWellFormedFormula();
                }

            }
            catch (Exception e)
            {
                Trace.WriteLine(e);
            }
            finally
            {
                Shutdown();
            }

        }

        protected void Setup()
        {
            foreach (var formula in _database.GetAllNonCanonicalFormulas())
            {
                _recognizer.Add(formula);
            }
        }

        public void ProcessFormula(Formula formula)
        {

            ReductionRule reductionRule = FormulaCanBeReduced(formula);
            if (reductionRule == null)
            {

                var isCanonical = IsCanonicalFormula(formula);

                if (isCanonical)
                {
                    Trace.WriteLine(formula + " is canonical.");
                }
                else
                {
                    _recognizer.Add(formula);
                    reductionRule = new ReductionRule(formula, _database.FindCanonicalFormula(formula));
                    Trace.WriteLine("Found a new reduction rule: " + reductionRule);
                }

                _database.AddFormula(formula, isCanonical);
            }
            else
            {
                Trace.WriteLine(formula + " can be reduced using rule " + reductionRule);
            }
        }

        private bool IsCanonicalFormula(Formula formula)
        {
            var truthTable = TruthTable.GetTruthTable(formula);
            int length = _database.GetLengthOfCanonicalFormulas(truthTable);

            // if there are no canonical formulas in the database then this is the first
            if (length <= 0)
                return true;

            // if the length of the formulas is longer than the equivalent canonical formula 
            // then it can't be canonical
            if (length < formula.Length)
                return false;

            if (length == formula.Length)
            {
                /* 
                 * In order to eventually be able to prove that TermSAT is confluent, there can only be 
                 * a single canonical form for any formula.
                 * So, if there is already a canonical formula with the same truth table 
                 * as this formula then we make this formula a reduction rule.
                 * 
                 * NOTE:  The FormulaGenerator class should be pumping out formulas in the same order 
                 * as the TermSAT formula ordering, implemented by Formula.CompareTo.  So the canonical 
                 * formula for any truth value should be the 'simplest' formula among the all shortest 
                 * formulas that have the same truth table.
    			 */
                if (0 < _database.GetCanonicalFormulas(truthTable).Count)
                    return false;
            }

            return true;
        }

        /*
         * A formula can be reduced if it is a substitution instance of 
         * a previously generated non-canonical formula.
         * Since new formulas are assembled from previously generated canonical 
         * formulas all subformulas of the given formula are guaranteed
         * to be non-reducible.   
         */
        private ReductionRule FormulaCanBeReduced(Formula formula)
        {
            SubstitutionInstance match = _recognizer.FindFirstGeneralization(formula);
            if (match == null)
                return null;
            Formula canonicalFormula = _database.FindCanonicalFormula(match.Generalization);

            // if 
            //  the canonical form of the generalization is the same length as the generalization 
            //  (in other words, if the result of applying the associated reduction rule will 
            //  result in a new formula of the same length as the formula being checked) 
            // then 
            //  the formula to be checked is only reducible if the reduced formula is simpler
            //
            // This check is required because the reduction rules that reduce all the shortest 
            // formulas for a truth table to a single formula are conditional, they are only 
            // applied when the result is 'simpler'.
            if (canonicalFormula.Length == match.Generalization.Length)
            {
                var reducedFormula = canonicalFormula.CreateSubstitutionInstance(match.Substitutions);
                if (0 <= reducedFormula.CompareTo(formula))
                    return null;
            }

            return new ReductionRule(match.Generalization, canonicalFormula);
        }

        private void Shutdown()
        {
            _database.Dispose();
        }



    }


}
