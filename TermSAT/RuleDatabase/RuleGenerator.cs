/*******************************************************************************
 * termsat SAT solver
 *     Copyright (C) 2010 Ted Stockwell <emorning@yahoo.com>
 * 
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Affero General Public License as
 *     published by the Free Software Foundation, either version 3 of the
 *     License, or (at your option) any later version.
 * 
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Affero General Public License for more details.
 * 
 *     You should have received a copy of the GNU Affero General Public License
 *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
using System;
using System.Diagnostics;
using TermSAT.Formulas;

namespace TermSAT.RuleDatabase
{


    /**
     * This program generates a beginning database of reduction rules for reducing 
     * propositional statements that are substitution instances instances of formulas 
     * with 3 or less variables.
     * 
     * For a given truth table, we call the shortest possible formulas with 
     * the given truth table 'canonical'.  Longer formulas are non-canonical.
     * This program generates reduction rules by generating every possible 
     * propositional formula of a given length and its associated truth table.
     * If a formula is non-canonical and is not reducible by a previous rule 
     * then it is a new reduction rule and is added to the database of reduction rules.
     * 
     * This program starts by generating all formulas with a length of 1, then 
     * it will generate all formulas with a length of 2, and so on.
     * This program stops generating reduction rules when every possible formula 
     * that is <= to twice the length of the longest canonical formula has been 
     * generated (because formulas longer than that are guaranteed to be reducible
     * by a previously generated reduction rule). 
     * 
     * The database of basic reduction rules generated by this program is then 
     * used as input into the RuleIndexer program.  
     * 
     * @see doc/summary.wiki for a more complete description of all the applications 
     * in the termSAT project.
     * 
     * @author Ted Stockwell
     */
    public class RuleGenerator
    {

        public static void Main(string[] args)
        {
            new RuleGenerator().run();
        }

        private FormulaGenerator _formulaGenerator;
        private RuleDatabase _database;
        private InstanceRecognizer _recognizer = new InstanceRecognizer();


        public void run()
        {

            try
            {
                setup();

                Formula formula = _formulaGenerator.getStartingFormula();

                while (formula != null)
                {

                    processFormula(formula);
                    formula = _formulaGenerator.getNextWellFormedFormula();
                }

            }
            catch (Exception e)
            {
                Trace.WriteLine(e);
            }
            finally
            {
                shutdown();
            }

        }

        private void setup()
        {
            _database = new RuleDatabase();
            _formulaGenerator = new FormulaGenerator(_database);

            foreach (var formula in _database.GetAllNonCanonicalFormulas())
            {
                _recognizer.Add(formula);
            }
        }

        private void processFormula(Formula formula)
        {

            ReductionRule reductionRule = formulaCanBeReduced(formula);
            if (reductionRule == null)
            {

                var isCanonical = isCanonicalFormula(formula);

                if (isCanonical)
                {
                    Trace.WriteLine(formula + " is canonical.");
                }
                else
                {
                    _recognizer.Add(formula);
                    reductionRule = new ReductionRule(formula, _database.FindCanonicalFormula(formula));
                    Trace.WriteLine("Found a new reduction rule: " + reductionRule);
                }
                _database.AddFormula(formula, isCanonical);
            }
            else
            {
                Trace.WriteLine(formula + " can be reduced using rule " + reductionRule);
            }
        }

        private Boolean isCanonicalFormula(Formula formula)
        {
            int length = _database.GetLengthOfCanonicalFormulas(TruthTable.newTruthTable(formula));

            // if there are no canonical formulas in the database then this is the first
            if (length <= 0) 
                return true; 

            // if the length of the formulas is longer than the equivalent canonical formula 
            // then it can't be canonical
            if (length < formula.Length)
                return false;

            return true;
        }

        /*
         * A formula can be reduced if it is a substitution instance of 
         * a previously generated non-canonical formula.
         * Since new formulas are assembled from previously generated canonical 
         * formulas then all subformulas of the given formula are guaranteed
         * to be non-reducible.   
         */
        private ReductionRule formulaCanBeReduced(Formula formula)
        {
            SubstitutionInstance match = _recognizer.findFirstGeneralization(formula);
            if (match == null)
                return null;
            Formula canonicalFormula = _database.FindCanonicalFormula(match.Generalization);
            return new ReductionRule(match.Generalization, canonicalFormula);
        }

        private void shutdown()
        {
            _database.Shutdown();
        }



    }


}
