using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Collections.Generic;
using System.Text;
using TermSAT.Formulas;
using TermSAT.RuleDatabase;

namespace TermSAT.Tests
{
    [TestClass]
    public class RuleDatabaseTests
    {

        FormulaDatabase database;

        [TestInitialize]
        public void Initialize()
        {
            database = new FormulaDatabase(":memory:");
        }

        [TestMethod]
        public void ConstantTruthTableTests()
        {
            var hexAllTrue = new String('F', TruthTable.VARIABLE_COUNT);
            var hexAllFalse = new String('0', TruthTable.VARIABLE_COUNT);

            // truth table for a formula
            var tt = TruthTable.GetTruthTable("T".ToFormula());
            Assert.AreEqual(hexAllTrue, tt.ToString());
            tt = TruthTable.GetTruthTable("F".ToFormula());
            Assert.AreEqual(hexAllFalse, tt.ToString());

            // truth table from hex string 
            tt = TruthTable.GetTruthTable(hexAllTrue);
            Assert.AreEqual(hexAllTrue, tt.ToString());
            tt = TruthTable.GetTruthTable(hexAllFalse);
            Assert.AreEqual(hexAllFalse, tt.ToString());

            tt = TruthTable.GetTruthTable(Variable.NewVariable(1));
            var hexVarOne = new String('5', TruthTable.VARIABLE_COUNT);
            Assert.AreEqual(hexVarOne, tt.ToString());

        }

        [TestMethod]
        public void VariableTruthTableTests()
        {
            var tt = TruthTable.GetTruthTable(Variable.ONE);
            Assert.AreEqual("55", tt.ToString());

            tt = TruthTable.GetTruthTable(Variable.TWO);
            Assert.AreEqual("33", tt.ToString());

            tt = TruthTable.GetTruthTable(Variable.THREE);
            Assert.AreEqual("0F", tt.ToString());
        }

        /// <summary>
        /// 
        /// In order to eventually be able to prove that TermSAT is confluent, there can only be 
        /// a single canonical representation of any formula.
        /// The first formula generated by the RuleGenerator for any particular truth table 
        /// must be the 'simplest' formula for that truth table.
        /// This method verifies that the RuleGenerator generates formulas in order, thereby ensuring 
        /// that canonical formulas are the simplest formula with the associated truth table.
        /// </summary>
        [TestMethod]
        public void RuleGeneratorOrderTests()
        {
            var formulaGenerator= new FormulaGenerator(database, TruthTable.VARIABLE_COUNT);
            var generator= new RuleGenerator(database, formulaGenerator);
            var formula= formulaGenerator.GetStartingFormula();

            var formulas= new List<Formula>();
            for (int i= 1000; 0 < i--;)
            {
                formulas.Add(formula);
                generator.ProcessFormula(formula);

                var previousFormula= formula;
                formula = formulaGenerator.GetNextWellFormedFormula();

                Assert.IsTrue(previousFormula.CompareTo(formula) < 0);
                Assert.IsTrue(0 < formula.CompareTo(previousFormula));
            }
        }

        [TestMethod]
        public void FormulaGeneratorTests()
        {
            Formula formula= null;

            /// the following sequence of operations is essentially what the RuleGenerator does
            /// when it first starts up
            var generator= new FormulaGenerator(database, TruthTable.VARIABLE_COUNT);

            var startingFormulaSequence= new List<Formula> { "T", "F", ".1", ".2", ".3" };

            foreach( var f in startingFormulaSequence)
            {
                formula= (formula == null) ? generator.GetStartingFormula() : generator.GetNextWellFormedFormula();
                Assert.AreEqual(f, formula);
                database.AddFormula(formula, isCanonical:true);
            }
            Assert.AreEqual(startingFormulaSequence.Count, database.CountCanonicalFormulas());

            foreach( var f in startingFormulaSequence)
            {
                formula= generator.GetNextWellFormedFormula();
                var n= Negation.NewNegation(f);
                Assert.AreEqual(n, formula);
                var tt= database.GetCanonicalFormulas(TruthTable.GetTruthTable(n));
                if (tt.Count < 0)
                    database.AddFormula(n, isCanonical:true);
            }

            formula= generator.GetNextWellFormedFormula();
            Assert.AreEqual("*TT", formula);

            formula= generator.GetNextWellFormedFormula();
            Assert.AreEqual("*TF", formula);
            formula= generator.GetNextWellFormedFormula();
            Assert.AreEqual("*T.1", formula);
            formula= generator.GetNextWellFormedFormula();
            Assert.AreEqual("*T.2", formula);
            formula= generator.GetNextWellFormedFormula();
            Assert.AreEqual("*T.3", formula);
            formula= generator.GetNextWellFormedFormula();
            Assert.AreEqual("*FT", formula);
            formula= generator.GetNextWellFormedFormula();
            Assert.AreEqual("*FF", formula);
            formula= generator.GetNextWellFormedFormula();
            Assert.AreEqual("*F.1", formula);
            formula= generator.GetNextWellFormedFormula();
            Assert.AreEqual("*F.2", formula);
            formula= generator.GetNextWellFormedFormula();
            Assert.AreEqual("*F.3", formula);
            formula= generator.GetNextWellFormedFormula();
            Assert.AreEqual("*.1T", formula);
            formula= generator.GetNextWellFormedFormula();
            Assert.AreEqual("*.1F", formula);
        }
    }
}
