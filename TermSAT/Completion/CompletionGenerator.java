/*******************************************************************************
 * termsat SAT solver
 *     Copyright (C) 2010 Ted Stockwell <emorning@yahoo.com>
 * 
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Affero General Public License as
 *     published by the Free Software Foundation, either version 3 of the
 *     License, or (at your option) any later version.
 * 
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Affero General Public License for more details.
 * 
 *     You should have received a copy of the GNU Affero General Public License
 *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
package com.googlecode.termsat.core.ruledb;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.googlecode.termsat.core.Constant;
import com.googlecode.termsat.core.Formula;
import com.googlecode.termsat.core.Variable;
import com.googlecode.termsat.core.solver.RuleRepository;
import com.googlecode.termsat.core.solver.Solver;


/**
 * This program implements the 
 * <a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Bendix_completion_algorithm">Knuth-Bendix completion algorithm</a> 
 * for propositional formulas.
 * 
 * After creating a CompletionGenerator call the run method to start the completion process.
 * New found rules are returned through the Enumeration<ReductionRule> returned from the run method.
 * 
 * @author Ted Stockwell
 */
public class CompletionGenerator 
{
	private readonly List<ReductionRule> _rules;
	private readonly Solver _solver;
	const boolean[] _done= new boolean[] { false };
	const ArrayList<ReductionRule> _found= new ArrayList<ReductionRule>();
	
	public CompletionGenerator(List<ReductionRule> rules) throws SQLException {
		_rules= rules;
		
//		// initialize rule set with all rules from generated by the RuleGenerator program
//		RuleDatabase ruleDatabase= new RuleDatabase();
//		ResultIterator<Formula> nonCanonicalFormulas= ruleDatabase.getAllNonCanonicalFormulas();
//		while (nonCanonicalFormulas.hasNext()) {
//			Formula nonCanonicalFormula= nonCanonicalFormulas.next();
//			ReductionRule rule= new ReductionRule(nonCanonicalFormula, ruleDatabase.findCanonicalFormula(nonCanonicalFormula));
//			_rules.add(rule);
//			System.out.println("Added rule #"+_rules.size()+": "+rule);
//		}
		
		RuleRepository repository= new RuleRepository();
		_solver= new Solver(repository);
	}
	
	
	
	public Enumeration<ReductionRule> run() {
		// start completion process
		new Thread() {
			override public void run() {
				complete();
			}
		}.start();
		
		return new Enumeration<ReductionRule>() {
			public ReductionRule nextElement() {
				while (true) {
					synchronized (_found) {
						if (!_found.isEmpty()) {
							ReductionRule rule= _found.remove(0);
							return rule;
						}
						try {
							_found.wait();
						}
						catch (InterruptedException x) {
						}
					}
				}
			}
			
			public boolean hasMoreElements() {
				while (true) {
					synchronized (_found) {
						if (!_found.isEmpty()) {
							return true;
						}
						if (_done[0])
							return false;
						try {
							_found.wait();
						}
						catch (InterruptedException x) {
						}
					}
				}
			}
		};
	}
	
	
	void complete() {
// http://comjnl.oxfordjournals.org/content/34/1/2.full.pdf		
// axiom set - set of equations initially containing formulas generated by the 
//			   RuleGenerator program
// rule set  - an initially empty set of rewrite rules
// reduction - the process of repeatedly applying reduction rules to a formula 		
// superposition - the process of finding a critical pair by unifying all subterms of the left hand sides of two rules		
//
// while axiom set is not empty
//		select and remove an axiom from the axiom set
//		Reduce the selected axiom
//		if the axiom is not of the form x=x then
//			Introduce it as a new rule in the rule set.
//			Superpose the new rule on all existing rules, including itself, and 
//			introduce each new critical pair into the axiom set		
//		end if		
// 
//
			// Create list of formulas *and* all subformulas used for superposition.
			// Iterating through this list (instead of iterating through all formulas and then considering 
			// all the subformulas of each left-hand side of each rule) eliminates a whole 
			// lot of duplicate subformulas
			HashMap<Formula, List<ReductionRule>> subformulasAndRules= new HashMap<Formula, List<ReductionRule>>();
			for (int i= 0; i < _rules.size(); i++) {
				ReductionRule reductionRule= _rules.get(i);
				Formula left= reductionRule.formula; // left side of existing rule
				List<Formula> all= left.getAllSubterms();
				for (Formula formula : all) {
					
					// according to the paper cited above we can skip variables 
					// and constants since they will not produce critical terms 
					// of any value
					if (formula is Constant)
						continue;
					if (formula is Variable)
						continue;
										
					List<ReductionRule> rules= subformulasAndRules.get(formula);
					if (rules == null) {
						rules= new ArrayList<ReductionRule>();
						subformulasAndRules.put(formula, rules);
					}
					rules.add(reductionRule);
				}
			}
			ArrayList<Formula> subformulas= new ArrayList<Formula>(subformulasAndRules.keySet());
			
			
			// now try to generate a new rule
			for (int i= 0; i < subformulas.size(); i++) {
				Formula subformula1= subformulas.get(i);
				List<ReductionRule> reductionRules1= subformulasAndRules.get(subformula1); // all the rules that have subformula1 in the left side of the rule
				System.out.println("Processing rule "+i+" out of "+subformulas.size()+ " : "+subformula1);
				
				// now, superpose the new rule on all subterms of all previously added rules, including itself
				for (int j= 0; j < subformulas.size(); j++) {
					Formula s2= subformulas.get(j);
					List<ReductionRule> reductionRules2= subformulasAndRules.get(s2); // all the rules that have s2 in the left side of the rule
					Formula subformula2= s2.createIndependentInstance(subformula1); // make formulas independent by using different variables
					
					// get critical term (per http://comjnl.oxfordjournals.org/content/34/1/2.full.pdf)
					// and the rules that created the term
					Map<Variable, Formula> unification= Formula.unify(subformula2, subformula1);
					if (unification != null) {
						for (ReductionRule reductionRule1 : reductionRules1) {
							for (ReductionRule reductionRule2 : reductionRules2) {
								for (Formula left: new Formula[] { subformula1, subformula2 }) {
									Formula criticalTerm= Formula.createInstance(left, unification);

									// reduce the critical term using the reduction rules
									Formula reduction1= Formula.reduceUsingRule(criticalTerm, reductionRule1);
									Formula reduction2= Formula.reduceUsingRule(criticalTerm, reductionRule2);
									
//									// normalize the formulas produced by the rules (that is, reduce them to their canonical form)
//									Formula normalized1, normalized2, normalizedCritical= null;
//									if (reduction1 == null) {
//										normalizedCritical= _solver.reduce(criticalTerm);
//										normalized1= normalizedCritical;
//									}
//									else
//										normalized1= _solver.reduce(reduction1);
//									if (reduction2 == null) {
//										if (normalizedCritical == null)
//											normalizedCritical= _solver.reduce(criticalTerm);
//										normalized2= normalizedCritical;
//									}
//									else
//										normalized2= _solver.reduce(reduction2);
									
									if (reduction1 == null || reduction2 == null)
										continue;
									Formula normalized1= _solver.reduce(reduction1);
									Formula normalized2= _solver.reduce(reduction2);
									
									if (!Formula.syntacticallyEqual(normalized1, normalized2)) {
										System.out.println("Found new rule...");
										System.out.println("while adding this rule: "+reductionRule1);
										System.out.println("superposed against this rule: "+reductionRule2);
										System.out.println("1st part of rule: "+normalized1);
										System.out.println("2nd part of rule: "+normalized2);
										
										ReductionRule rule= new ReductionRule(normalized1, normalized2);
										synchronized (_found) {
											assert false : "WHOAAAAA, WE FOUND A NEW REDUCTION RULE";
											//_solver.addRule(rule);
											_rules.add(rule);
											_found.add(rule);
											_found.notifyAll();
										}
									}
								}
							}
						}
					}
				}
			}
			
			synchronized (_found) {
				_done[0]= true;
				_found.notifyAll();
			}
	}
}
