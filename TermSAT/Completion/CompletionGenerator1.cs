/*******************************************************************************
 * termsat SAT solver
 *     Copyright (C) 2010 Ted Stockwell <emorning@yahoo.com>
 * 
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU Affero General Public License as
 *     published by the Free Software Foundation, either version 3 of the
 *     License, or (at your option) any later version.
 * 
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU Affero General Public License for more details.
 * 
 *     You should have received a copy of the GNU Affero General Public License
 *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
using System.Collections.Generic;

namespace TermSAT.Completion
{


    /**
     * This program implements the 
     * <a href="http://en.wikipedia.org/wiki/Knuth%E2%80%93Bendix_completion_algorithm">Knuth-Bendix completion algorithm</a> 
     * for propositional formulas.
     * 
     * After creating a CompletionGenerator call the run method to start the completion process.
     * New found rules are returned through the Enumeration<ReductionRule> returned from the run method.
     * 
     * @author Ted Stockwell
     */
    public class CompletionGenerator1
    {
        private readonly List<ReductionRule> _rules;
        private readonly Solver _solver;
        const boolean[] _done = new boolean[] { false };
        const ArrayList<ReductionRule> _found = new ArrayList<ReductionRule>();

        public CompletionGenerator1(List<ReductionRule> rules) throws SQLException
        {
            _rules= rules;

            //		// initialize rule set with all rules from generated by the RuleGenerator program
            //		RuleDatabase ruleDatabase= new RuleDatabase();
            //		ResultIterator<Formula> nonCanonicalFormulas= ruleDatabase.getAllNonCanonicalFormulas();
            //		while (nonCanonicalFormulas.hasNext()) {
            //			Formula nonCanonicalFormula= nonCanonicalFormulas.next();
            //			ReductionRule rule= new ReductionRule(nonCanonicalFormula, ruleDatabase.findCanonicalFormula(nonCanonicalFormula));
            //			_rules.add(rule);
            //			System.out.println("Added rule #"+_rules.size()+": "+rule);
            //		}

            RuleRepository repository= new RuleRepository();
        _solver= new Solver(repository);
    }



    public Enumeration<ReductionRule> run()
    {
        // start completion process
        new Thread()
        {
			override public void run()
        {
            complete();
        }
    }.start();
		
		return new Enumeration<ReductionRule>() {
			public ReductionRule nextElement()
    {
        while (true)
        {
            synchronized(_found) {
                if (!_found.isEmpty())
                {
                    ReductionRule rule = _found.remove(0);
                    return rule;
                }
                try
                {
                    _found.wait();
                }
                catch (InterruptedException x)
                {
                }
            }
        }
    }

    public boolean hasMoreElements()
    {
        while (true)
        {
            synchronized(_found) {
                if (!_found.isEmpty())
                {
                    return true;
                }
                if (_done[0])
                    return false;
                try
                {
                    _found.wait();
                }
                catch (InterruptedException x)
                {
                }
            }
        }
    }
};
	}
	
	
	void complete()
{
    // http://comjnl.oxfordjournals.org/content/34/1/2.full.pdf		
    // axiom set - set of equations initially containing formulas generated by the 
    //			   RuleGenerator program
    // rule set  - an initially empty set of rewrite rules
    // reduction - the process of repeatedly applying reduction rules to a formula 		
    // superposition - the process of finding a critical pair by unifying all subterms of the left hand sides of two rules		
    //
    // while axiom set is not empty
    //		select and remove an axiom from the axiom set
    //		Reduce the selected axiom
    //		if the axiom is not of the form x=x then
    //			Introduce it as a new rule in the rule set.
    //			Superpose the new rule on all existing rules, including itself, and 
    //			introduce each new critical pair into the axiom set		
    //		end if		
    // 
    //


    // now try to generate a new rule
    for (int i = 0; i < _rules.size(); i++)
    {

        ReductionRule reductionRule1 = _rules.get(i);
        Formula left1 = reductionRule1.formula; // the left side of the new rule
        System.out.println("Processing rule " + i + " out of " + _rules.size() + " : " + left1);

        // now, superpose the new rule on all previously added rules, including itself
        for (int j = 0; j < _rules.size(); j++)
        {
            ReductionRule reductionRule2 = _rules.get(j); // existing rule
            Formula left2 = reductionRule2.formula; // left side of existing rule
            left2 = left2.createIndependentInstance(left1); // make formulas independent by using different variables

            // get all critical terms (per http://comjnl.oxfordjournals.org/content/34/1/2.full.pdf)
            List<Formula> criticalTerms = Formula.findAllCriticalTerms(left1, left2);

            for (Formula criticalTerm : criticalTerms)
            {
                Formula reduction1 = Formula.reduceUsingRule(criticalTerm, reductionRule1);
                Formula reduction2 = Formula.reduceUsingRule(criticalTerm, reductionRule2);

                if (reduction1 != null || reduction2 != null)
                {
                    if (reduction1 == null)
                        reduction1 = criticalTerm;
                    if (reduction2 == null)
                        reduction2 = criticalTerm;

                    Formula normalized1 = _solver.reduce(reduction1);
                    Formula normalized2 = _solver.reduce(reduction2);

                    if (!Formula.syntacticallyEqual(normalized1, normalized2))
                    {
                        System.out.println("Found new rule...");
                        System.out.println("while adding this rule: " + reductionRule1);
                        System.out.println("superposed against this rule: " + reductionRule2);
                        System.out.println("1st part of rule: " + normalized1);
                        System.out.println("2nd part of rule: " + normalized2);

                        ReductionRule rule = new ReductionRule(normalized1, normalized2);
                        synchronized(_found) {
                            assert false : "WHOAAAAA, WE FOUND A NEW REDUCTION RULE";
                            //_solver.addRule(rule);
                            _rules.add(rule);
                            _found.add(rule);
                            _found.notifyAll();
                        }
                    }
                }
            }
        }
    }

    synchronized(_found) {
        _done[0] = true;
        _found.notifyAll();
    }
}
}
}

