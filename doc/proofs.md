# Proofs

TermSAT is 'SAT solver' for a system of propositional logic based on formulas in 'nand normal form'.
TermSAT doesn't work like other SAT solvers, TermSAT is not based on clausal resolution.  
TermSAT is a rule-based, [term rewriting system](https://en.wikipedia.org/wiki/Rewriting#Term_rewriting_systems).  
TermSAT 'solves' formulas by reducing them to their [canonical form](https://en.wikipedia.org/wiki/Canonical_form).  
TermSAT reduces formulas by repeatedly applying simple rewrite rules to formulas.  
The catch is that there are *a lot* of rules, so TermSAT saves them in a ([Sqlite](https://www.sqlite.org/)) database.  
The TermSAT solver itself is pretty simple, the logic is in the rules, not the solver.  
Another way to think about it is, the database is a rule-based program, and the TermSAT solver is an interpreter that runs the program.  

nand-normal-form uses just nand operators and variables.  No constants.  No negation.  
TermSAT uses nand-normal-form to represent formulas because, 
by reducing the # of operators to just 1 and removing constants, 
its possible to construct an initial set of reduction rules that can be shown to be [locally confluent](https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)#Local_confluence).   

TermSATs' database of rules is generated by a script included in the TermSAT project, see TermSAT.Nand.Scripts.RunNandRuleGenerator.
This script essentially runs, to termination, a version of the [Knuth–Bendix completion algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Bendix_completion_algorithm) 
over TermSATs core set of locally confluent rules, thus generating a rule set that is globally confluent.  

This document...
- defines the TermSAT system in detail, 
- describes how the rule generator works
- includes proofs of the claims that...
	- The core set of rules is locally confluent
	- The *completed* rule set, in the Knuth-Bendix sense, is globally confluent.
	- TermSAT reduces formulas to their canonical form in less than O(2N), where N is the length of the starting formula.

This document contains a proof that TermSAT reduces formulas in polynomial time complexity.

## Formula Syntax

Nand formulas consist of the constants T and F, variables, and NAND operators.  
'TermSAT Normal Form' is further restricted, formulas consist of just variables and NAND operators, no constants.  
Formulas in TermSAT Normal Form are referred to as 'TermSAT formulas'.
TermSAT uses TermSAT formulas because it's possible to show that the starting rules for the TermSAT system are locally confluent.  

Formulas are represented in a textual form...
The normal form uses Polish notation and...
...the symbols 'T' and 'F' for TRUE and FALSE.
...the symbol '|' for the nand operator, followed by the antecedent and then the subsequent. 
...by the symbol '.' followed by an integer number greater than 0 for representing variables.

Some examples of formulas...
F
T
.1
|.1T
|.1.3
||.1.3|.3|F.4

## Length
A formulas length is defines like so...
- Constants and variables have a length of 1
- The length of a Nand formula is 1 (the length of the operator) plus...
	- the length of its antecendent 
	- the length of its subsequent 

Note that you can calculate the length of a nand formula by...
- counting the '|' characters, 
- multiplying by 2, 
- and adding 1.

## TermSAT Numbering

TermSAT formulas can be assigned a number by replacing nand symbols with 0' and removing dots.
Examples... 
```
||.2|.1|.1.1||.1.2||.1.1|.3|.1.2 => 002010110012001103012
.2 => 2
```

## Ordering

See the Formula.CompareTo method for an implementation of the ordering.

TermSAT depends on first defining an ordering of all formulas.
The purpose of this ordering is to provide a method of determining the 'complexity' of a formula.  
The ultimate purpose of such an ordering is to provide the basis for 
creating a confluent set of reduction rules for reducing proposition formulas.
Such an ordering is a necessary condition for producing such a set of rules. 
One consequence of imposing an ordering on formulas is that there is one, 
and only one, 'canonical' way to represent a given formula.


Basically the rules, in order, are...
1. Constants are before any other formulas, T is before F.  
2. Variables are before than any other formulas, except Constants.  
	1. Variables are assigned a number, variables with lower numbers are before other variables
3. Shorter formulas are before longer formulas.  
4. The lower the TermSAT number the lower the formula in the order.

Examples..
Rule 1: T comes before .1
Rule 2: .2 comes before |TT 
Rule 3: |.2.2 comes before |.1|.1.1
Rule 4: |.2.1 comes before |.3.1 
Rule 5: |.1.2 comes before |.1.3

### Sorting formulas in a database 

The TermSAT a database uses two columns, TEXT and LENGTH, where...
	- TEXT stores the textual form of the formula
	- LENGTH stores the length of the formula
then formulas may be selected in formula order by sorting by LENGTH and then by TEXT.
	> Like so, SELECT * FROM Formulas ORDER By Length, Text

The textual representation of formulas was explicitly designed to make this possible.

## Reductions
A reduction is a transform from a starting formula to a 'reduced' formula 
that is 'less than' the starting formula in the formula ordering.  

In TermSAT a reduction is specified as two formulas, a starting formula and reduced formula, 
and an enumeration of positions, for each term in the reduced formula

## The 'Reductive Logic System'
The 'Reductive Logic System' (or system R) is the name for the logic system for which NandSAT was built.  
The difference between system R and other logic systems is most logic systems have a limited # of deductive rules.  
	
## Nand Reduction 
Nand reduction is just a set of abstract reductions, executed in the following order....

- constant elimination
	- |TT => F
	- |TF => T, |FT => T, |FF => T
	- |F.1 => T &&  |.1F => T ** these rules are central to wildcard analysis **
	- |T|T.1 => .1
	
- ordering rules
	- |ba <=> |ab
	- (|b|T|ac <=> |a|T|bc) =>*
	- (||ab|ac <=> |T|a||Tb|Tc) =>*
	- (||a|bc||Tac <=> ||a|Tb|b|ac) =>*
Notes...	
	- Ordering rules are only applied when the result would be 'less than' the starting formula
	- =>* indicates repeatedly reducing until reaching canonical form
	- a <=> b means that the reduction is bidirectional, that is, a formula may be reducible 
		by applying the reduction in either direction.
	
- wildcard analysis.  Described in the next section.  
	- f => f.FlatTerm.Replace(s, s(a => C)), for some subterms s & a, and some constant C

NOTE...
One thing that NandSAT can prove is that the above set of reductions is capable of reducing 
all formulas with no more than three variables to their canonical form.  
NandSAT can also reduce formulas that are substitution instances of simpler, reducible formulas.  
In addition, proving that NandSAT's reductions can reduce formulas of 6 or fewer variables 
would prove that NandSAT is strongly confluent and that NandSATs' set of reduction is complete.

NOTE...
Many of the currently hard-coded 'ordering' rules are actually rules of the form ||ab|ac -> |T|a||Tb|Tc.
It's not immediately apparent that rules of this form actually result in reducing formulas because 
|T|a||Tb|Tc is longer than ||ab|ac.  
However, here's an example of one such reduction....
||.1.2|.1|.3|T.2 => |T|.1|.3|T.2
=> |T|.1||T.2|T|.3|T.2, ordering rule ||ab|ac -> |T|a||Tb|Tc
=> |T|.1||T.2|T|.3|T.F, last .2 is a wildcard when first .2 is T
=> |T|.1||T.2|T|.3T, constant elimination
=> |T|.1||T.2.3, constant elimination
=> |T|.1|.3|T.2, formula ordering
	
# Wildcard Analysis

Wildcard analysis is an algorithm that discovers subterms in a formula that may be replaced with a constant.  
Wildcards are discovered by 'testing' a formula by substituting a constant for a selected subterm and, 
in the process of reducing the result of the substitution to its canonical form, 
discovers other matching subterms that can be replaced in the starting formula.  
Wildcard analysis does most of the grunt work of reducing formulas.

Notation:
 Let $f be a formula
 Let $f.A refers to f's antecedent
 Let $f.S refers to f's subsequent
 Let $f.A* be the set of all sub-formulas of A
Theorem:
 Assume f.A and f.S are canonical, ie not reducible.
 For any $a in f.A* except T and F...
     For all $c in [T,F]
         If
             replacing all instances of $a in f.A with $c and reducing the result 
			 causes a matching subterm in the f.S to be removed by application of the rule |F$a => T
         then
             the removed instance $a in f.S may be replaced by $c ? F:T, the opposite of C.
 Similarly for all $s in f.S* except T and F...
     For all $c in [T,F]
         If
             replacing all instances of $s in f.S with $c and reducing the result 
			 causes a matching subterm in the f.A to be removed by application of the rule |F$a => T
         then
             the removed instance $a in f.A may be replaced by $c ? F:T, the opposite of C.

## Examples

### |.1|.1.2 => |.1|T.2
test .1 => F in antecedent
=> |F|.1.2, wildcard identified: .1 @ position 3
therefore replace .1 in subsequent with T...
=> |.1|T.2 

# Applying Reduction rules
Must 

// |.1||.2|T.3|.3|T.2 => ||.2.3||.1.2|.1.3

## Trie idea for competitive solver
NandSAT's native reduction algorithm gebarety

