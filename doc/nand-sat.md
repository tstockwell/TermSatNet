# NandSAT - A SAT solver with a polynomial time complexity.  

NandSAT is a 'SAT solver' for a system of propositional logic based on formulas in 'nand normal form'.  
NandSAT doesn't work like other SAT solvers, it doesn't use resolution, it's a [term rewriting system](https://en.wikipedia.org/wiki/Rewriting#Term_rewriting_systems).  
NandSAT 'solves' formulas by reducing them to their [canonical form](https://en.wikipedia.org/wiki/Canonical_form).  
NandSAT reduces formulas by repeatedly applying simple rewrite rules to formulas.  
The catch is that there are *a lot* of rules, so NandSAT saves them in a ([Postgres](https://www.postgresql.org/)) database  
and then uses this database to reduce rules.  
The NandSAT solver itself is pretty simple because the 'logic' is in the rules, not the solver.  
Another way to think about it is, the database is a rule-based program, 
and the NandSAT solver is an interpreter that runs the program using a given nand formula as input.  
And its possible to show that, for the particular set of rules in the nandsat database, 
that the 'program' will terminate in a number of steps that's polynomially proportional to the length of the formula.  

nand-normal-form uses just nand operators and variables.  No constants.  No negation.  
NandSAT uses nand-normal-form to represent formulas because, 
by reducing the # of operators to just 1 and removing constants, 
its possible to construct an initial set of reduction rules that can be shown to be [locally confluent](https://en.wikipedia.org/wiki/Confluence_(abstract_rewriting)#Local_confluence).   

NandSATs' database of rules is generated by a script included in the NandSAT project, see NandSAT.Nand.Scripts.RunNandRuleGenerator.
This script essentially runs, to termination, a version of the [Knuth–Bendix completion algorithm](https://en.wikipedia.org/wiki/Knuth%E2%80%93Bendix_completion_algorithm) 
over NandSATs core set of locally confluent rules, thus generating a rule set that is globally confluent.  

This document...
- defines the NandSAT system in detail, 
- describes how the rule generator works
- includes proofs of the claims that...
	- The core set of rules is locally confluent
	- The *completed* rule set, in the Knuth-Bendix sense, is globally confluent.
	- NandSAT reduces formulas to their canonical form in less than O(2N), where N is the length of the starting formula.

This document contains a proof that NandSAT reduces formulas in polynomial time complexity.

## Formula Syntax

Nand formulas consist of the constants T and F, variables, and NAND operators.  
'NandSAT Normal Form' is further restricted, formulas consist of just variables and NAND operators, no constants.  
Formulas in NandSAT Normal Form are referred to as 'NandSAT formulas'.
NandSAT uses NandSAT formulas because it's possible to show that the starting rules for the NandSAT system are locally confluent.  

Formulas are represented in a textual form...
The normal form uses Polish notation and...
...the symbols 'T' and 'F' for TRUE and FALSE.
...the symbol '|' for the nand operator, followed by the antecedent and then the subsequent. 
...by the symbol '.' followed by an integer number greater than 0 for representing variables.

Some examples of formulas...
F
T
.1
|.1T
|.1.3
||.1.3|.3|F.4

## Length
A formulas length is defines like so...
- Constants and variables have a length of 1
- The length of a Nand formula is 1 (the length of the operator) plus...
	- the length of its antecendent 
	- the length of its subsequent 

Note that you can calculate the length of a nand formula by...
- counting the '|' characters, 
- multiplying by 2, 
- and adding 1.

## NandSAT Numbering

NandSAT formulas can be assigned a number by replacing nand symbols with 0' and removing dots.
Examples... 
```
||.2|.1|.1.1||.1.2||.1.1|.3|.1.2 => 002010110012001103012
.2 => 2
```

## Ordering


Basically the rules, in order, are...
1. Constants are before any other formulas, T is before F.  
2. Formulas where the highest numbered variable is X come before formulas where the highest numbered variable is Y, and X < Y
3. Shorter formulas are before longer formulas.  
4. Formulas of the same length are sorted lexically.  

Examples..
Rule 1: T comes before .1
Rule 2: |.1.2 comes before .3
Rule 3: |.2.1 comes before |.1|.1.2
Rule 4: |.2.3 comes before |.3.1 
Rule 4: |.3.2 comes before |.3.3

NandSAT depends on first defining an ordering of all formulas.
The purpose of this ordering is to provide a method of determining the 'complexity' of a formula.  
The ultimate purpose of such an ordering is to provide the basis for 
creating a confluent set of reduction rules for reducing proposition formulas.
Such an ordering is a necessary condition for producing such a set of rules. 
One consequence of imposing an ordering on formulas is that there is one, 
and only one, 'canonical' way to represent a given formula.

See the Formula.CompareTo method for an implementation of the ordering.  

This ordering matches the order in which the 'rule database' is constructed.  
See NandSAT.Nand.Scripts.RunNandRuleGenerator.

### Sorting formulas in a database 

The NandSAT a database uses two columns, TEXT and LENGTH, where...
	- TEXT stores the textual form of the formula
	- LENGTH stores the length of the formula
then formulas may be selected in formula order by sorting by LENGTH and then by TEXT.
	> Like so, SELECT * FROM Formulas ORDER By Length, Text

The textual representation of formulas was explicitly designed to make this possible.

## Reductions
A reduction is a transform from a starting formula to a 'reduced' formula 
that is 'less than' the starting formula in the formula ordering.  

In NandSAT a reduction is specified as two formulas, a starting formula and reduced formula, 
and an enumeration of positions, for each term in the reduced formula

## The 'Reductive Logic System'
The 'Reductive Logic System' (or system R) is the name for the logic system for which NandSAT was built.  
The difference between system R and other logic systems is most logic systems have a limited # of deductive rules.  
	
## Nand Reduction 
Nand reduction is just a set of abstract reductions, executed in the following order....

- constant elimination
	- |TT => F
	- |TF => T, |FT => T, |FF => T
	- |F.1 => T &&  |.1F => T ** these rules are central to wildcard analysis **
	- |T|T.1 => .1
	
- ordering rules
	- |ba <=> |ab
	- (|b|T|ac <=> |a|T|bc) =>*
	- (||ab|ac <=> |T|a||Tb|Tc) =>*
	- (||a|bc||Tac <=> ||a|Tb|b|ac) =>*
Notes...	
	- Ordering rules are only applied when the result would be 'less than' the starting formula
	- =>* indicates repeatedly reducing until reaching canonical form
	- a <=> b means that the reduction is bidirectional, that is, a formula may be reducible 
		by applying the reduction in either direction.
	
- wildcard analysis.  Described in the next section.  
	- f => f.FlatTerm.Replace(s, s(a => C)), for some subterms s & a, and some constant C

NOTE...
One thing that NandSAT can prove is that the above set of reductions is capable of reducing 
all formulas with no more than three variables to their canonical form.  
NandSAT can also reduce formulas that are substitution instances of simpler, reducible formulas.  
In addition, proving that NandSAT's reductions can reduce formulas of 6 or fewer variables 
would prove that NandSAT is strongly confluent and that NandSATs' set of reduction is complete.

NOTE...
Many of the currently hard-coded 'ordering' rules are actually rules of the form ||ab|ac -> |T|a||Tb|Tc.
It's not immediately apparent that rules of this form actually result in reducing formulas because 
|T|a||Tb|Tc is longer than ||ab|ac.  
However, here's an example of one such reduction....
||.1.2|.1|.3|T.2 => |T|.1|.3|T.2
=> |T|.1||T.2|T|.3|T.2, ordering rule ||ab|ac -> |T|a||Tb|Tc
=> |T|.1||T.2|T|.3|T.F, last .2 is a wildcard when first .2 is T
=> |T|.1||T.2|T|.3T, constant elimination
=> |T|.1||T.2.3, constant elimination
=> |T|.1|.3|T.2, formula ordering
	
# Wildcard Analysis

Wildcard analysis is an algorithm that discovers subterms in a formula that may be replaced with a constant.  
Wildcards are discovered by 'testing' a formula by substituting a constant for a selected subterm and, 
in the process of reducing the result of the substitution to its canonical form, 
discovers other matching subterms that can be replaced in the starting formula.  
Wildcard analysis does most of the grunt work of reducing formulas.

Notation:
 Let $f be a formula
 Let $f.A refers to f's antecedent
 Let $f.S refers to f's subsequent
 Let $f.A* be the set of all sub-formulas of A
Theorem:
 Assume f.A and f.S are canonical, ie not reducible.
 For any $a in f.A* except T and F...
     For all $c in [T,F]
         If
             replacing all instances of $a in f.A with $c and reducing the result 
			 causes a matching subterm in the f.S to be removed by application of the rule |F$a => T
         then
             the removed instance $a in f.S may be replaced by $c ? F:T, the opposite of C.
 Similarly for all $s in f.S* except T and F...
     For all $c in [T,F]
         If
             replacing all instances of $s in f.S with $c and reducing the result 
			 causes a matching subterm in the f.A to be removed by application of the rule |F$a => T
         then
             the removed instance $a in f.A may be replaced by $c ? F:T, the opposite of C.

## Examples

### |.1|.1.2 => |.1|T.2
test .1 => F in antecedent
=> |F|.1.2, wildcard identified: .1 @ position 3
therefore replace .1 in subsequent with T...
=> |.1|T.2 

# Applying Reduction rules
Must 

// |.1||.2|T.3|.3|T.2 => ||.2.3||.1.2|.1.3

## Trie idea for competitive solver
NandSAT's native reduction algorithm gebarety

